---
title: "Output Analysis"
subtitle: "Term 6 40.319 Simulation Modelling Analysis Project"
author: "Ong Kai Xin Chloe, Muhammad Zulfiqar, Yong Zhe Rui Gabriel and Pang Yew Ju Ethan"
date: "2023-03-20"
output: 
  rmdformats::downcute:
    thumbnails: false
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
```

## Preparing Data and Libraries for analysis

### Loading Libraries
```{r}
library(tidyr)
library(dplyr)
library(ggplot2)
library(factoextra)
```


### Read Train Data
```{r}
train1 <- read.csv("trainData1.csv")
train2 <- read.csv("trainData2.csv")
train3 <- read.csv("trainData3.csv")
train4 <- read.csv("trainData4.csv")
train5 <- read.csv("trainData5.csv")
train6 <- read.csv("trainData6.csv")
train7 <- read.csv("trainData7.csv")
train8 <- read.csv("trainData8.csv")
train9 <- read.csv("trainData9.csv")
train10 <- read.csv("trainData10.csv")
train11 <- read.csv("trainData11.csv")
train12 <- read.csv("trainData12.csv")
train13 <- read.csv("trainData13.csv")
train14 <- read.csv("trainData14.csv")
train15 <- read.csv("trainData15.csv")
train16 <- read.csv("trainData16.csv")
train17 <- read.csv("trainData17.csv")
train18 <- read.csv("trainData18.csv")
train19 <- read.csv("trainData19.csv")
train20 <- read.csv("trainData20.csv")
train <- rbind(train1,train2,train3,train4,
               train5,train6,train7,train8,
               train9,train10,train11,train12,
               train13,train14,train15,train16,
               train17,train18,train19,train20)
```


### Read station data
```{r}
station1 <- read.csv("stationData1.csv")
station2 <- read.csv("stationData2.csv")
station3 <- read.csv("stationData3.csv")
station4 <- read.csv("stationData4.csv")
station5 <- read.csv("stationData5.csv")
station6 <- read.csv("stationData6.csv")
station7 <- read.csv("stationData7.csv")
station8 <- read.csv("stationData8.csv")
station9 <- read.csv("stationData9.csv")
station10 <- read.csv("stationData10.csv")
station11 <- read.csv("stationData11.csv")
station12 <- read.csv("stationData12.csv")
station13 <- read.csv("stationData13.csv")
station14 <- read.csv("stationData14.csv")
station15 <- read.csv("stationData15.csv")
station16 <- read.csv("stationData16.csv")
station17 <- read.csv("stationData17.csv")
station18 <- read.csv("stationData18.csv")
station19 <- read.csv("stationData19.csv")
station20 <- read.csv("stationData20.csv")
station <- rbind(station1,station2,station3,station4,
                 station5,station6,station7,station8,
                 station9,station10,station11,station12,
                 station13,station14,station15,station16,
                 station17,station18,station19,station20)
```

```{r}
Stats <- aggregate(cbind(tapIn,tapOut,stationCount_mean) ~ hour+stationName,data=station,FUN=mean)
Ser <- subset(Stats,Stats$stationName == "Little India NE7/DT12")
ggplot(data=Ser,mapping=aes(x=hour,y=stationCount_mean))+geom_point()+geom_line()
```


# Understanding the accuracy of our simulation.

After creating the simulation, we ran the simulation 20times to obtain 20 independent runs.
We then use these values to run our post simulation analysis.

But first, we run some tests on the simulation output to make sure that our simulation is providing similar results to the existing data.

### Plotting the average station's Tap In and Tap Out data.
```{r}
Stats <- aggregate(cbind(tapIn,tapOut) ~ hour,data=station,FUN=mean)


ggplot() +
  # blue plot
geom_point(data=Stats, aes(x=hour, y=tapIn)) + 
geom_line(data=Stats, aes(x=hour, y=tapIn), fill="green",
              colour="green") +
  # red plot
geom_point(data=Stats, aes(x=hour, y=tapOut)) + 
geom_line(data=Stats, aes(x=hour, y=tapOut), fill="orange",
              colour="orange")
```

The graph plotted matches that of our pre-simulation analysis Weekday data which is a good indicator that our simulation is an accurate representation of Singapore's MRT system.

Now let's perform some PCA along with kmeans clustering and check if the hour clusters match that of our pre-simulation analysis.

## PCA-Kmeans analysis

```{r}
Stats <- aggregate(cbind(tapIn,tapOut) ~ hour+stationName,data=station,FUN=mean)
Stats <- subset(Stats,hour!=6)
Stats <- subset(Stats,hour!=24)

wider <- pivot_wider(Stats, names_from= stationName, values_from = c(tapIn, tapOut))
wider <- mutate_all(wider, ~replace_na(.,0))
pca_data <- data.frame(wider[,-1])
rownames(pca_data) <- wider$hour
pca_data <- mutate_all(pca_data, ~replace_na(.,0))
k2 <- kmeans(scale(pca_data), centers=4, nstart=25)
fviz_cluster(k2, data = pca_data, ellipse.type = "euclid")

fviz_nbclust(scale(pca_data), kmeans, nstart=100, method = "wss") + 
  geom_vline(xintercept = 4, linetype = 1)
```

As we can see here, the Kmeans clustering has similar groups to that of our pre simulation analysis on the raw data. This can show that our simulation is an accurate representation of the actual MRT system.
However, we still need to do more tests to confirm the accuracy of our simulation. 

## Matching Tap In/Tap Out data with our pre-simulation analysis

```{r}
Stats <- aggregate(cbind(tapIn,tapOut) ~ hour + stationName,data=station,FUN=mean)
#unique(station$stationName)
# RP <- subset(Stats,stationName=="City Hall NS25/EW13")
# RP <- subset(Stats,stationName=="Raffles Place NS26/EW14")
RP <- subset(Stats,stationName=="Serangoon NE12/CC13")
#Stats <- subset(Stats,stationName=="Springleaf MRT Station TE4")
ggplot() +
  # blue plot
geom_point(data=RP, aes(x=hour, y=tapIn)) + 
geom_line(data=RP, aes(x=hour, y=tapIn), fill="green",
              colour="green") +
  # red plot
geom_point(data=RP, aes(x=hour, y=tapOut)) + 
geom_line(data=RP, aes(x=hour, y=tapOut), fill="orange",
              colour="orange") +
  
ggtitle("TapIn & TapOut by hour for Raffles Place NS26/EW14")
```

By plotting out Raffles Place NS26/EW14 we can see a similar Tap In and Tap out distribution. The large spike in Tap In data from 1700h - 1900h and 0800h - 0900h in Tap Out data reaffirms our simulation.

```{r}
Som <- subset(Stats,stationName=="Somerset NS23")
ggplot() +
  # blue plot
geom_point(data=Som, aes(x=hour, y=tapIn)) + 
geom_line(data=Som, aes(x=hour, y=tapIn), fill="green",
              colour="green") +
  # red plot
geom_point(data=Som, aes(x=hour, y=tapOut)) + 
geom_line(data=Som, aes(x=hour, y=tapOut), fill="orange",
              colour="orange") +
  
ggtitle("TapIn & TapOut by hour for Somerset NS23")
```

By plotting out Somerset NS23 we can see a similar Tap In and Tap out distribution. The relatively constant values of Tap In and Tap out data for Somerset are similar to that of our pre-simulation analysis and confirms the accuracy of our simulation.

# Finding out the problem area in our system

## Performing PCA to find the pain points

It would make sense that high Tap in and Tap out data will make sense with congestion. Even though we cannot prove that with the raw data, we are able to use our simulation to find out the wait times associated with the stations that are highly commuted to. 

We first perform PCA analysis on the data by station before clustering them using kmeans clustering to try figure out if the clusters formed can provide any insight into the congested stations. 

```{r}
Stats <- aggregate(cbind(tapIn,tapOut) ~ hour+stationName,data=station,FUN=mean)
Stats <- subset(Stats,hour!=6)
Stats <- subset(Stats,hour!=24)

wider <- pivot_wider(Stats, names_from = hour, values_from = c(tapIn, tapOut))
#wider <- mutate_all(wider, ~replace_na(.,0))
pca_data <- data.frame(wider[,-1])
rownames(pca_data) <- wider$stationName
pca_data <- mutate_all(pca_data, ~replace_na(.,0))
k2 <- kmeans(scale(pca_data), centers=4, nstart=25)
fviz_cluster(k2, data = pca_data, ellipse.type = "euclid")

fviz_nbclust(scale(pca_data), kmeans, nstart=100, method = "wss") + 
  geom_vline(xintercept = 4, linetype = 1)
```

From the plot generated, we can quickly catch on to the fact that cluster 1 contains stations that are highly commuted to. Some stations include Jurong East, Raffles Place and Chinatown. Cluster 4 also contains stations that are frequently commuted to, incorporating stations like Bishan, Serangoon and Tampines.

Clusters 2 & 3 are more positive in terms of Dim1 as compared to Clusters 1 & 4. Instinctively, we assume that these stations in clusters 2 & 3 generally have less congested stations. 

## Understanding our clusters

Using the clusters that we have established in the previous portion, we can now perform a more in depth analysis into these station to find out why they have been clustered together.

```{r}
rownames(as.data.frame(subset(k2$cluster,k2$cluster == 1 | k2$cluster == 4)))
df <- as.data.frame(subset(k2$cluster,k2$cluster == 1 | k2$cluster == 4))
df1 <- as.data.frame(subset(k2$cluster,k2$cluster == 1))
df2 <- as.data.frame(subset(k2$cluster,k2$cluster == 2))
df3 <- as.data.frame(subset(k2$cluster,k2$cluster == 3))
df4 <- as.data.frame(subset(k2$cluster,k2$cluster == 4))
colnames(df) <- "Cluster"
colnames(df1) <- "Cluster"
colnames(df2) <- "Cluster"
colnames(df3) <- "Cluster"
colnames(df4) <- "Cluster"
# df
# df1
# df4
#View(df)
```

Function `ClusterData` takes in each cluster as a dataframe and returns a dataframe containing the Tap in and Tap out data of the stations in the cluster subsetted from the Stats dataframe.
```{r}
ClusterData <- function(df) {
  Stats <- aggregate(cbind(tapIn,tapOut) ~ hour+stationName,data=station,FUN=mean)
  Temp2 <- data.frame()
  for (i in 1:length(rownames(df))) {
    Temp1 <- subset(Stats,stationName==rownames(df)[i])
    Temp2 <- rbind(Temp2,Temp1)
  }
  return(Temp2)
}
```

## Plotting the clusters

We can now plot the graphs of each station split by cluster.

```{r}
Stats <- aggregate(cbind(tapIn,tapOut) ~ hour + stationName,data=station,FUN=mean)
Cluster1 <- ClusterData(df1)
Cluster2 <- ClusterData(df2)
Cluster3 <- ClusterData(df3)
Cluster4 <- ClusterData(df4)
ggplot(data=Cluster1,mapping=aes(x=hour,y=tapIn,color=stationName))+geom_point()+geom_line()+
  ggtitle("Tap In plot for Cluster 1") + guides(color = FALSE)
ggplot(data=Cluster2,mapping=aes(x=hour,y=tapIn,color=stationName))+geom_point()+geom_line()+
  ggtitle("Tap In plot for Cluster 2") + guides(color = FALSE)
ggplot(data=Cluster3,mapping=aes(x=hour,y=tapIn,color=stationName))+geom_point()+geom_line()+
  ggtitle("Tap In plot for Cluster 3") + guides(color = FALSE)
ggplot(data=Cluster4,mapping=aes(x=hour,y=tapIn,color=stationName))+geom_point()+geom_line()+
  ggtitle("Tap In plot for Cluster 4") + guides(color = FALSE)
ggplot(data=Cluster1,mapping=aes(x=hour,y=tapOut,color=stationName))+geom_point()+geom_line()+
  ggtitle("Tap Out plot for Cluster 1") + guides(color = FALSE)
ggplot(data=Cluster2,mapping=aes(x=hour,y=tapOut,color=stationName))+geom_point()+geom_line()+
  ggtitle("Tap Out plot for Cluster 2") + guides(color = FALSE)
ggplot(data=Cluster3,mapping=aes(x=hour,y=tapOut,color=stationName))+geom_point()+geom_line()+
  ggtitle("Tap Out plot for Cluster 3") + guides(color = FALSE)
ggplot(data=Cluster4,mapping=aes(x=hour,y=tapOut,color=stationName))+geom_point()+geom_line()+
  ggtitle("Tap Out plot for Cluster 4") + guides(color = FALSE)
```

From the cluster plots, we can clearly see that cluster 2 has the lowest number of Tap Ins and Tap Outs with values far less than 1000.

Cluster 3 has slightly more commuters tapping in and out with off peak values slightly below 1000. 

Cluster 4 and Cluster 1 have significantly higher commuter count during off peak hours, as well as high peaks during the peak hours. Difference between clusters 1 & 2 are when the stations experience the high peaks. Cluster 1 experiences its high peak in Tap ins in the evening and Tap outs in the morning. This indicates a station in a business area. Cluster 2 experiences its high peak in Tap ins in the morning and Tap outs in the evening. This indicates a station in a residential area.

# Finding out the congestion using waiting time

## Wait time analysis

Now that we have established that our simulation is an accurate representation of Singapore's MRT system and have identified the problem stations that we should be looking at, we can now look at the train data to further understand how we can improve the current simluation and hence provide a solution to the possible problems that our MRT system faces.

Again we will use PCA to attempt to find out the waiting time and train capacity in relation to hour and direction.

```{r}
trainStats <- data.frame()
for (i in 1:nrow(df)) {
  stations <- subset(train,train$stationName==rownames(df)[i])
  trainStats <- rbind(trainStats,stations)
}
trainStats <- aggregate(cbind(alightCount_mean, alightCount_count, boardCount_mean, boardCount_count, waitTime_mean,trainCount_mean) ~ hour+stationName+direction+line,data=trainStats,FUN=mean)
trainStats <- subset(trainStats,hour!=6)
trainStats <- subset(trainStats,hour!=24)
trainStats$stationName <- paste(trainStats$stationName,trainStats$line,trainStats$direction, sep=",")
trainStats <- trainStats[c(1,2,9,10)]

wider <- pivot_wider(trainStats, names_from = hour, values_from = c(waitTime_mean,trainCount_mean))
#wider <- mutate_all(wider, ~replace_na(.,0))
pca_data <- data.frame(wider[,-1])
rownames(pca_data) <- wider$stationName
pca_data <- mutate_all(pca_data, ~replace_na(.,0))
k2 <- kmeans(scale(pca_data), centers=4, nstart=25)
fviz_cluster(k2, data = pca_data, ellipse.type = "euclid")

fviz_nbclust(scale(pca_data), kmeans, nstart=100, method = "wss") + 
  geom_vline(xintercept = 4, linetype = 1)
```

```{r}
# rownames(as.data.frame(subset(k2$cluster,k2$cluster == 1 | k2$cluster == 4)))
df1 <- as.data.frame(subset(k2$cluster,k2$cluster == 1))
df2 <- as.data.frame(subset(k2$cluster,k2$cluster == 2))
df3 <- as.data.frame(subset(k2$cluster,k2$cluster == 3))
df4 <- as.data.frame(subset(k2$cluster,k2$cluster == 4))
colnames(df1) <- "Cluster"
colnames(df2) <- "Cluster"
colnames(df3) <- "Cluster"
colnames(df4) <- "Cluster"
```

Function `ClusterTrainData` takes in the cluster dataframe as an input and provides the traindata on those stations.

```{r}
ClusterTrainData <- function(df) {
  trainStats <- aggregate(cbind(alightCount_mean, alightCount_count, boardCount_mean, boardCount_count, waitTime_mean,trainCount_mean,trainCount_sd,trainCount_count) ~ hour+stationName+direction+line,data=train,FUN=mean)
  Temp2 <- data.frame()
  for (i in 1:length(rownames(df))) {
    rowname <- as.data.frame(strsplit(rownames(df)[i],","))[1,]
    Sline <- as.data.frame(strsplit(rownames(df)[i],","))[2,]
    Sdirection <- as.data.frame(strsplit(rownames(df)[i],","))[3,]
    Temp1 <- subset(trainStats,stationName==rowname & line==Sline & direction==Sdirection)
    Temp2 <- rbind(Temp2,Temp1)
  }
  return(Temp2)
}
```

We can now generate data frames to include the alightCount_mean, alightCount_count, boardCount_mean, boardCount_count, waitTime_mean & trainCount_mean.

```{r}
Cluster1TrainData <- ClusterTrainData(df1)
Cluster2TrainData <- ClusterTrainData(df2)
Cluster3TrainData <- ClusterTrainData(df3)
Cluster4TrainData <- ClusterTrainData(df4)
```

We plot the data of TrainCount_mean against hour by each station,line and direction.

```{r}
Cluster1TrainData$ID <- paste(Cluster1TrainData$stationName,Cluster1TrainData$direction,Cluster1TrainData$line,sep=",")
Cluster2TrainData$ID <- paste(Cluster2TrainData$stationName,Cluster2TrainData$direction,Cluster2TrainData$line,sep=",")
Cluster3TrainData$ID <- paste(Cluster3TrainData$stationName,Cluster3TrainData$direction,Cluster3TrainData$line,sep=",")
Cluster4TrainData$ID <- paste(Cluster4TrainData$stationName,Cluster4TrainData$direction,Cluster4TrainData$line,sep=",")
ggplot(data=Cluster1TrainData,mapping=aes(x=hour,y=trainCount_mean,color=ID))+geom_point()+geom_line() +
    ggtitle("TrainCount_mean for Cluster 1")
ggplot(data=Cluster2TrainData,mapping=aes(x=hour,y=trainCount_mean,color=ID))+geom_point()+geom_line() +
    ggtitle("TrainCount_mean for Cluster 2")
ggplot(data=Cluster3TrainData,mapping=aes(x=hour,y=trainCount_mean,color=ID))+geom_point()+geom_line() +
    ggtitle("TrainCount_mean for Cluster 3")
ggplot(data=Cluster4TrainData,mapping=aes(x=hour,y=trainCount_mean,color=ID))+geom_point()+geom_line() +
    ggtitle("TrainCount_mean for Cluster 4")
```

We can see that Cluster 1-4 differ in terms of the hour and magnitude of the spike in trainCount_mean as well as the average trainCount_mean value.

With each train having a capacity of 1000 commuters, we can set our own threshold trainCount_mean value of about 600. With this value, it is a safe estimate to ensure that no train is ever full at any point within the hour. Any trainCount_mean values above 600 will need to be dealt with by increasing the frequency of trains at those stations so as to reduce congestion. Because of this, we focus our attention to Cluster 1 & 4.

We can see that Cluster 1 receives it's crowd in the morning from 0700h - 0800h, while cluster 4 receives it crowd from 1700h - 1900h. Lets observer the crowds for each station within the cluster at those timings.

```{r}
subset(Cluster1TrainData,Cluster1TrainData$hour <= 8 & Cluster1TrainData$trainCount_mean>=600)
```



In Cluster 1 we can identify a few tracks that require a higher frequency of trains to clear the crowd between hours 0700h - 0800h. These tracks are:
`Newton DT11/NS21 FW dtl` `Clementi MRT Station EW23 BW ewl` `Serangoon NE12/CC13 BW nel` `Bukit Batok NS2 BW nsl`  `Ang Mo Kio NS16 FW nsl` `Bishan NS17/CC15 FW nsl` `Jurong East NS1/EW24 FW nsl` `Khatib NS14 FW nsl` `Novena NS20 FW nsl` `Toa Payoh NS19 FW nsl`.

```{r}
subset(Cluster4TrainData, 17 <= Cluster4TrainData$hour & Cluster4TrainData$hour <= 19 & Cluster4TrainData$trainCount_mean>=600)
```

In Cluster 4 we can identify a few tracks that require a higher frequency of trains to clear the crowd between hours 1700h - 1900h. These tracks are:
`Newton DT11/NS12 BW dtl` `Clementi MRT Station EW23 FW ewl` `Jurong East NS1/EW24` `Ang Mo Kio NS16 BW nsl` `Khatib NS14 BW nsl` `Toa Payoh NS19 BW nsl` `Bukit Batok NS2 FW nsl`.



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
